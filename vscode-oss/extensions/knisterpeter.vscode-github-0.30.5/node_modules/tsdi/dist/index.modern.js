import"reflect-metadata";function t(){return(t=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t}).apply(this,arguments)}const e=(()=>{const t=t=>-1!==(t||"").indexOf("tsdi")||"*"===t;return"object"==typeof exports&&"undefined"!=typeof module?t(process.env.DEBUG):"undefined"!=typeof window&&t(window.localStorage.getItem("DEBUG"))})(),n=t=>{const n=(t,...n)=>{if(!e)return;if(t instanceof Error)return void console.error(t);const o=[];let i=0,r=0,s=t.indexOf("%",r);for(;-1!==s;){switch(o.push(t.substring(r,s)),t.substr(s,2)){case"%o":o.push(n[i++]);break;case"%s":o.push(String(n[i++]))}r=s+2,s=t.indexOf("%",r)}r<t.length&&o.push(t.substring(r)),console.log(...o)};return n.enabled=e,n};function o(t){return Boolean(t.rtti)}function i(t,e){let n=-1;for(let o=0,i=t.length;o<i;o++)e(t[o])&&(n=o);return n}function r(t){return"string"==typeof t?{name:t}:t}let s=[];const a=[],c=[];function p(t){if(t.options.name&&i(a,e=>e.options.name===t.options.name)>-1)throw new Error(`Duplicate name '${t.options.name}' for known Components.`);a.push(t),s.forEach(e=>e(t))}const d=n();function f(...t){const e=(t,e={})=>{d("@Component "+t.name);const n=r(e);return p({fn:t,options:n}),Reflect.defineMetadata("component:options",n,t),t};return 1===t.length&&"function"==typeof t[0]?e(t[0],{}):function(n){return e(n,t[0]||{})}}const l=f,h=n();function m(...t){const e=(t,e)=>{h("@Destroy %s#%s",t.constructor.name,e),Reflect.defineMetadata("component:destroy",e,t)};return t.length>0?e(t[0],t[1]):function(t,n){e(t,n)}}const y=m,u=n();function g(...t){const e=t=>{u("@External "+t.name),function(t){(function(t){return-1!==i(c,e=>e===t)})(t)||(c.push(t),s.forEach(e=>e(t)))}(t);const e=function(...e){return t.__tsdi__.configureExternal(e,t)};return Object.defineProperty(e,"name",{value:t.name}),Object.defineProperty(e,"__tsdi__external__",{value:t}),e.displayName=t.name,Object.getOwnPropertyNames(t).filter(t=>"name"!==t&&"length"!==t&&"caller"!==t&&"callee"!==t&&"arguments"!==t&&!e[t]).forEach(n=>e[n]=t[n]),e.prototype=t.prototype,e};return t.length>0?e(t[0]):function(t){return e(t)}}const I=g,C=n();function M(...t){const e=(t,e,n)=>{C.enabled&&C('@Factory %s#%s({name: "%s"})',t.constructor.name,e,t[e].name),p({target:t,property:e.toString(),options:n,rtti:Reflect.getMetadata("design:returntype",t,e)})};if(t.length>1)return e(t[0],t[1],{});const n=t[0]||{};return function(t,o){e(t,o,n)}}const j=M,w=n();function _(...t){const e=(t,e)=>{w("@Initialize %s#%s",t.constructor.name,e),Reflect.defineMetadata("component:init",e,t);const n=Reflect.getMetadata("design:returntype",t,e)===Promise;Reflect.defineMetadata("component:init:async",n,t)};return t.length>0?e(t[0],t[1]):function(t,n){e(t,n)}}const O=_,b=n();function R(...t){const e=t=>{const e=r(t||{});return void 0===e.lazy&&(e.lazy=!0),e},n=(t,e,n)=>{b(`@Inject ${t.constructor.name}#${String(e)}`);const o=Reflect.getMetadata("design:type",t,e);let i=Reflect.getMetadata("component:injects",t);i||(i=[],Reflect.defineMetadata("component:injects",i,t)),i.push({target:t,property:e.toString(),options:n,type:o})},o=(t,e,n,o)=>{b("@Inject "+String(e));let i=Reflect.getMetadata("component:parameters",t);i||(i=[],Reflect.defineMetadata("component:parameters",i,t)),i.push({options:o,index:n,rtti:Reflect.getMetadata("design:paramtypes",t)[n]})};if(!(t.length>1))return function(i,r,s){const a=e(t[0]||{});return void 0===s?n(i,r,a):o(i,r,s,a)};{const i=e({});void 0===t[2]?n(t[0],t[1],i):o(t[0],t[1],t[2],i)}}const v=R;function E(...t){const e=(t,e)=>{Reflect.defineMetadata("component:configured",!0,t,e);const n=t[e.toString()],o=`__tsdi__${e.toString()}__`,i=Reflect.getMetadata("design:returntype",t,e),r=Reflect.getMetadata("design:type",t,e);return{configurable:!0,enumerable:!0,writable:!0,value:function(){if(!i)return this.__tsdi__.get(r);if(o in this)return this[o];const s=Reflect.getMetadata("design:paramtypes",t,e).map(t=>this.__tsdi__.get(t)),a=n.call(this,...s);return Object.defineProperty(this,o,{configurable:!1,enumerable:!1,writable:!1,value:a}),a}}};return t.length>0?e(t[0],t[1]):(t,n)=>e(t,n)}const z=n();class x{constructor(t,e){this.autoMock=void 0,this.components=[],this.instances={},this.properties={},this.lifecycleListeners=[],this.scopes={},this.registerComponent({fn:x,options:{}}),this.instances[0]=this,t&&(this.registerComponent({fn:t.constructor,options:{}}),this.instances[1]=t,Object.defineProperty(t,"__tsdi__",{configurable:!1,enumerable:!1,writable:!1,value:this}),Object.getOwnPropertyNames(t.constructor.prototype).filter(e=>Reflect.getMetadata("component:configured",t.constructor.prototype,e)).forEach(e=>{const n=Reflect.getMetadata("design:returntype",t,e);if(n)this.registerComponent({target:t,property:e,options:{},rtti:n});else{const n=Reflect.getMetadata("design:type",t,e);n.__tsdi__external__?n.__tsdi__external__.__tsdi__=this:this.registerComponent({fn:n,options:{}})}})),this.parent=e}addLifecycleListener(t){return this.lifecycleListeners.push(t),Object.keys(this.instances).forEach(t=>this.notifyOnCreate(this.instances[parseInt(t,10)])),Object.values(this.instances).map(t=>[t,this.getInitializerPromise(t)]).forEach(([t,e])=>null==e?void 0:e.then(()=>this.notifyOnReady(t))),()=>{const e=this.lifecycleListeners.findIndex(e=>e===t);this.lifecycleListeners.splice(e,1)}}notifyOnCreate(t){this.lifecycleListeners.forEach(e=>null==e.onCreate?void 0:e.onCreate(t))}notifyOnReady(t){this.lifecycleListeners.forEach(e=>null==e.onReady?void 0:e.onReady(t))}notifyOnDestroy(t){this.lifecycleListeners.forEach(e=>null==e.onDestroy?void 0:e.onDestroy(t))}addProperty(t,e){this.properties[t]=e}close(){var t;Object.keys(this.instances).forEach(t=>{const e=parseInt(t,10),n=this.components[e];o(n)||this.destroyInstance(e,n)}),this.instances=[],this.listener&&(t=this.listener,s=function(e,n){const o=i(e,e=>e===t);return o>-1?[...e.slice(0,o),...e.slice(o+1)]:e}(s),this.listener=void 0)}destroyInstance(t,e){const n=this.instances[t];if(n){this.notifyOnDestroy(n);const i=Reflect.getMetadata("component:destroy",o(e)?e.rtti:e.fn.prototype);i&&n[i]&&n[i].call(n),this.instances[t]=void 0}}enableComponentScanner(){var t;this.listener||(this.listener=t=>{"function"==typeof t?t.__tsdi__=this:this.registerComponent(t)},this.listener&&(s.push(t=this.listener),a.forEach(e=>t(e)),c.forEach(e=>t(e))))}enableAutomock(...t){console.warn("#enableAutomock is deprecated and should not be used. Instead use #override."),this.autoMock=t}registerComponent(t){if(-1===this.components.indexOf(t)&&(t.options.name&&i(this.components,e=>e.options.name===t.options.name)>-1&&console.warn(`Component with name '${t.options.name}' already registered.`),this.markAsyncInitializer(t),z("registerComponent %o",o(t)?t.rtti.name:t.fn.name),this.components.push(t),t.options.eager)){const e=this.components.length-1;setTimeout(()=>{this.getOrCreate(t,e)},0)}}markAsyncInitializer(t){if(o(t)){const e=Reflect.getMetadata("component:init:async",t.target.constructor.prototype);Reflect.defineMetadata("component:init:async",e,t.rtti.prototype)}else{const e=Reflect.getMetadata("component:init:async",t.fn.prototype),n=(Reflect.getMetadata("component:injects",t.fn.prototype)||[]).some(t=>t.type&&Reflect.getMetadata("component:init:async",t.type.prototype));!e&&n&&Reflect.defineMetadata("component:init:async",!0,t.fn.prototype)}}register(e,n){const o=Reflect.getMetadata("component:options",e)||{};this.registerComponent({fn:e,options:t({},o,{name:n||o.name})})}getComponentMetadataIndex(t,e){for(let n=0,o=this.components.length;n<o;n++)if(e){if(e===this.components[n].options.name)return n}else if(this.isComponentMetadataIndexFromComponentOrFactory(t,this.components[n]))return n;return-1}isComponentMetadataIndexFromComponentOrFactory(t,e){return void 0!==t&&(o(e)?e.rtti:e.fn)===t}throwComponentNotFoundError(t,e,n){throw t&&!e&&(e=t.name),e||(e="unknown"),new Error(`Component '${e}' not found${n?": "+n:""}`)}getConstructorParameters(t){const e=Reflect.getMetadata("component:parameters",t.fn);return e?e.sort((t,e)=>t.index-e.index).map(t=>({index:this.getComponentMetadataIndex(t.rtti,t.options.name)})).map(({index:t})=>this.getOrCreate(this.components[t],t)):[]}isSingleton(t){return void 0===t.options.singleton||t.options.singleton}getOrCreateFactory(t){return this.get(t.target.constructor)}hasAsyncFactoryInitializer(t){const e=this.getOrCreateFactory(t),n=this.getInitializerPromise(e);return Boolean(n)}getOrCreate(t,e){z("> getOrCreate %o",t);let n=this.instances[e];return n&&this.isSingleton(t)||(o(t)?(z("create %o from factory with %o",t.rtti.name,t.options),n=this.getOrCreateFactory(t)[t.property](),this.instances[e]=n):n=this.createComponent(t,e),this.notifyOnCreate(n)),z("< getOrCreate %o -> %o",t,n),n}addInitializerPromise(t,e){e&&Reflect.defineMetadata("tsdi:initialize:promise",e,t)}getInitializerPromise(t){return Reflect.getMetadata("tsdi:initialize:promise",t)}createComponent(t,e){this.hasEnteredScope(t)||this.throwComponentNotFoundError(t.fn,void 0,`required scope '${t.options.scope}' is not enabled`),z("create %o with %o",t.fn.name,t.options);const n=new(0,t.fn)(...this.getConstructorParameters(t));this.instances[e]=n,this.injectIntoInstance(n,!1,t);const o=Reflect.getMetadata("component:init",t.fn.prototype);return this.maybeLazyInitialize(n,o,t),n}waitForInjectInitializers(t){const e=Reflect.getMetadata("component:injects",t.fn.prototype);if(e&&e.some(t=>Reflect.getMetadata("component:init:async",t.type.prototype)))return Promise.all(e.map(t=>{const[e,n]=this.getInjectComponentMetadata(t),i=o(e)?this.getOrCreateFactory(e):this.getOrCreate(e,n);return this.getInitializerPromise(i)}))}hasEnteredScope(t){return!t.options.scope||Boolean(t.options.scope&&this.scopes[t.options.scope])}configureExternal(t,e){const n={fn:e,options:{}},o=new e(...t,...this.getConstructorParameters({fn:e,options:{}}));this.injectIntoInstance(o,!0,n);const i=Reflect.getMetadata("component:init",e.prototype);return this.maybeLazyInitialize(o,i,n),o}maybeLazyInitialize(t,e,n){const o=this.waitForInjectInitializers(n);e?this.addInitializerPromise(t,o?o.then(()=>t[e].call(t)||Promise.resolve()).then(()=>this.notifyOnReady(t)):(t[e].call(t)||Promise.resolve()).then(()=>this.notifyOnReady(t))):o?(o.then(()=>this.notifyOnReady(t)),this.addInitializerPromise(t,o)):this.notifyOnReady(t)}injectIntoInstance(t,e,n){const o=Reflect.getMetadata("component:injects",n.fn.prototype);if(o)for(const i of o)z("injecting %s.%s",t.constructor.name,i.property),i.options.name&&void 0!==this.properties[i.options.name]?t[i.property]=this.properties[i.options.name]:this.injectDependency(t,e,i,n)}injectDependency(t,e,n,o){if(!this.injectAutoMock(t,n))if(this.isAsyncInitializerDependency(n)||!n.options.lazy&&!n.options.dynamic)this.isAsyncFactoryInjection(n)?this.createAsyncFactoryInjection(t,n):t[n.property]=this.getComponentDependency(n,o,e);else{const i=this;Object.defineProperty(t,n.property,{configurable:!0,enumerable:!0,get(){z("lazy-resolve injected property %s.%s",t.constructor.name,n.property);const r=i.getComponentDependency(n,o,e);return n.options.dynamic?r:(Object.defineProperty(t,n.property,{enumerable:!0,value:r}),z("lazy-resolved injected property %s.%s <- %o",t.constructor.name,n.property,t[n.property]),t[n.property])}})}}createAsyncFactoryInjection(t,e){const[n]=this.getInjectComponentMetadata(e);if(!o(n))throw new Error("Illegal state: async factory injection without factory metadata");const i=this.getOrCreateFactory(n),r=this.getInitializerPromise(i);let s=!1;r&&r.then(()=>{s=!0}),Object.defineProperty(t,e.property,{configurable:!0,enumerable:!0,get(){if(s){const o=i[n.property]();return Object.defineProperty(t,e.property,{enumerable:!0,value:o}),o}throw new Error("Illegal state: need to wait for factory to resolve")}})}isAsyncFactoryInjection(t){const[e]=this.getInjectComponentMetadata(t);return!!o(e)&&this.hasAsyncFactoryInitializer(e)}isAsyncInitializerDependency(t){const[e]=this.getInjectComponentMetadata(t),n=o(e)?this.hasAsyncFactoryInitializer(e):Reflect.getMetadata("component:init:async",e.fn.prototype);if(n&&t.options.dynamic)throw new Error(`Injecting ${t.type.name} into ${t.target.constructor.name}#${t.property} must not be dynamic since ${t.type.name} has an async initializer`);return n}injectAutoMock(t,e){if(!this.autoMock)return!1;const[n]=this.getInjectComponentMetadata(e);if(n){const i=o(n)?n.rtti:n.fn;if(this.autoMock.indexOf(i)>-1)return!1;const r=this.mock(i);if(r)return t[e.property]=r,!0}return!1}createAutoMock(t){if(!this.autoMock||this.autoMock.indexOf(t)>-1)return;const e={__tsdi__mock__:"This is a TSDI automock"},n=t.prototype;return Object.getOwnPropertyNames(n).forEach(t=>{"function"==typeof n[t]&&(e[t]=function(...t){return t})}),e||void 0}mock(t){console.warn("#mock is deprecated and should not be used. Instead use #override.");const e=this.getComponentMetadataIndex(t);if(!this.instances[e]){const n=this.createAutoMock(t);if(!n)throw new Error("Failed to create mock from "+t.name);this.instances[e]=n}return this.instances[e]}getInjectComponentMetadata(t){let e=this.getComponentMetadataIndex(t.type,t.options.name);-1===e&&(this.checkAndThrowDependencyError(t),e=this.getComponentMetadataIndex(t.type,t.type.name));const n=this.components[e];if(!n){if(this.parent)return this.parent.getInjectComponentMetadata(t);throw new Error(`Failed to get inject '${t.type.name||t.options.name}' for '${t.target.constructor.name}#${t.property}'`)}return[n,e]}getComponentDependency(t,e,n){const[i,r]=this.getInjectComponentMetadata(t);return n||t.options.dynamic||o(i)||!i.options.scope||e.options.scope||console.warn(`Component '${i.fn.name}' is scoped to '${i.options.scope}' and injected into '${e.fn.name}' without scope. This could easily lead to stale references. Consider to add the scope '${i.options.scope}' to '${e.fn.name}' as well or make the inject dynamic.`),this.getOrCreate(i,r)}checkAndThrowDependencyError(t){if(t.type&&t.options.name){const e=new Error("Injecting undefined type on "+t.target.constructor.name+`#${t.property}: Component named '${t.options.name}' not found`);throw z(e),z("Known Components: %o",this.components.map(t=>o(t)?t.rtti.name:t.fn.name)),e}if(!t.type||t.options.name){const e=new Error("Injecting undefined type on "+t.target.constructor.name+`#${t.property}: Probably a cyclic dependency, switch to name based injection`);throw z(e),e}}get(t,e){let n;"string"==typeof t?(e=t,n=void 0):n=t;const o=this.getComponentMetadataIndex(n,e),i=this.components[o];if(!i){if(this.parent)return this.parent.get(t);this.throwComponentNotFoundError(n,e)}return this.getOrCreate(i,o)}async asyncGet(t){return new Promise(e=>{const n=this.addLifecycleListener({onReady(o){o instanceof t&&(n(),e(o))}});this.get(t)})}override(t,e){const n=this.getComponentMetadataIndex(t);this.instances[n]=e,z("Override %o with %o",t,e)}getScope(t){const e=this;return{enter(){e.scopes[t]=!0},leave(){delete e.scopes[t],e.components.filter(e=>!o(e)&&e.options.scope===t).forEach(t=>{const n=e.getComponentMetadataIndex(o(t)?t.rtti:t.fn);e.destroyInstance(n,t)})}}}}export{f as Component,E as Configure,m as Destroy,g as External,M as Factory,_ as Initialize,R as Inject,x as TSDI,l as component,E as configure,y as destroy,I as external,j as factory,O as initialize,v as inject};
//# sourceMappingURL=index.modern.js.map
