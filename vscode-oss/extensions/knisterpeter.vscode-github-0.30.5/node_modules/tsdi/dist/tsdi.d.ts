import 'reflect-metadata';
export declare type Constructable<T> = {
    new (...args: any[]): T;
};
export declare type IComponentOptions = ComponentOptions;
export interface ComponentOptions {
    name?: string;
    singleton?: boolean;
    eager?: boolean;
    scope?: string;
}
export declare type IInjectOptions = InjectOptions;
export interface InjectOptions {
    name?: string;
    lazy?: boolean;
    dynamic?: boolean;
}
export declare type IFactoryOptions = FactoryOptions;
export interface FactoryOptions {
    name?: string;
    singleton?: boolean;
    eager?: boolean;
}
export declare type Mock<T> = {
    -readonly [P in keyof T]: T[P];
};
export interface LifecycleListener {
    onCreate?(component: any): void;
    onReady?(component: any): void;
    onDestroy?(component: any): void;
}
export declare class TSDI {
    private autoMock;
    private readonly components;
    private instances;
    private listener;
    private readonly properties;
    private readonly lifecycleListeners;
    private readonly scopes;
    private readonly parent;
    constructor(configuration?: Object, parent?: TSDI);
    addLifecycleListener(lifecycleListener: LifecycleListener): () => void;
    private notifyOnCreate;
    private notifyOnReady;
    private notifyOnDestroy;
    addProperty(key: string, value: any): void;
    close(): void;
    private destroyInstance;
    enableComponentScanner(): void;
    enableAutomock(...allowedDependencies: any[]): void;
    private registerComponent;
    private markAsyncInitializer;
    register(component: Constructable<any>, name?: string): void;
    private getComponentMetadataIndex;
    private isComponentMetadataIndexFromComponentOrFactory;
    private throwComponentNotFoundError;
    private getConstructorParameters;
    private isSingleton;
    private getOrCreateFactory;
    private hasAsyncFactoryInitializer;
    private getOrCreate;
    private addInitializerPromise;
    private getInitializerPromise;
    private createComponent;
    private waitForInjectInitializers;
    private hasEnteredScope;
    configureExternal<T>(args: unknown[], target: any): T;
    private maybeLazyInitialize;
    private injectIntoInstance;
    private injectDependency;
    private createAsyncFactoryInjection;
    private isAsyncFactoryInjection;
    private isAsyncInitializerDependency;
    private injectAutoMock;
    private createAutoMock;
    mock<T>(component: Constructable<T>): Mock<T>;
    private getInjectComponentMetadata;
    private getComponentDependency;
    private checkAndThrowDependencyError;
    get<T>(componentOrHint: string | Constructable<T>): T;
    get<T>(component: Constructable<T>, hint: string): T;
    asyncGet<T>(component: Constructable<T>): Promise<T>;
    override(component: Constructable<any>, override: any): void;
    getScope(name: string): {
        enter(): void;
        leave(): void;
    };
}
export { component, Component } from './component';
export { destroy, Destroy } from './destroy';
export { external, External } from './external';
export { factory, Factory } from './factory';
export { initialize, Initialize } from './initialize';
export { inject, Inject } from './inject';
export { configure, Configure } from './configure';
//# sourceMappingURL=tsdi.d.ts.map