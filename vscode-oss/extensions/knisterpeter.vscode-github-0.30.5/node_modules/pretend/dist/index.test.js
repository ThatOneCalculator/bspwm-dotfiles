"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-implicit-dependencies
require("isomorphic-fetch");
require("isomorphic-form-data");
var nock_1 = __importDefault(require("nock"));
var decorators_1 = require("./decorators");
var index_1 = require("./index");
var UserClass = /** @class */ (function () {
    function UserClass(data) {
        this.user = data.user;
    }
    UserClass.transform = function (_a) {
        var firstName = _a.firstName, lastName = _a.lastName;
        return [{ user: firstName + " " + lastName }];
    };
    return UserClass;
}());
var TestImpl = /** @class */ (function () {
    function TestImpl() {
    }
    TestImpl.prototype.getSimple = function () {
        /* */
    };
    TestImpl.prototype.get = function (_id) {
        /* */
    };
    TestImpl.prototype.getWithQuery = function (_id, _parameters) {
        /* */
    };
    TestImpl.prototype.getWithHeader = function () {
        /* */
    };
    TestImpl.prototype.post = function (_body) {
        /* */
    };
    TestImpl.prototype.postWithQueryAndBody = function () {
        /* */
    };
    TestImpl.prototype.postWithFormData = function (_formData) {
        /* */
    };
    TestImpl.prototype.postWithFormDataAndQuery = function (_query, _formData) {
        /* */
    };
    TestImpl.prototype.postWithEmptyFormDataAndQuery = function (_query, _formData) {
        /* */
    };
    TestImpl.prototype.postWithUrlEncodedBody = function (_query, _body) {
        /* */
    };
    TestImpl.prototype.put = function () {
        /* */
    };
    TestImpl.prototype.putWithQuery = function (_parameters) {
        /* */
    };
    TestImpl.prototype.delete = function (_id) {
        /* */
    };
    TestImpl.prototype.deleteBody = function (_id, _body) {
        /* */
    };
    TestImpl.prototype.deleteWithQuery = function (_id, _query) {
        /* */
    };
    TestImpl.prototype.patchBody = function (_id, _body) {
        /* */
    };
    TestImpl.prototype.withResponseType = function () {
        /* */
    };
    TestImpl.prototype.withResponseTypeAndTransform = function () {
        /* */
    };
    __decorate([
        index_1.Get('/path', true)
    ], TestImpl.prototype, "getSimple", null);
    __decorate([
        index_1.Get('/path/{id}')
    ], TestImpl.prototype, "get", null);
    __decorate([
        index_1.Get('/path/{id}', true)
    ], TestImpl.prototype, "getWithQuery", null);
    __decorate([
        index_1.Headers('Accept: accept'),
        index_1.Get('/with/header')
    ], TestImpl.prototype, "getWithHeader", null);
    __decorate([
        index_1.Post('/path')
    ], TestImpl.prototype, "post", null);
    __decorate([
        index_1.Post('/path', true)
    ], TestImpl.prototype, "postWithQueryAndBody", null);
    __decorate([
        index_1.Post('/path/withFormData', true),
        __param(0, index_1.FormData('name'))
    ], TestImpl.prototype, "postWithFormData", null);
    __decorate([
        index_1.Post('/path/withFormData', true),
        __param(1, index_1.FormData('name'))
    ], TestImpl.prototype, "postWithFormDataAndQuery", null);
    __decorate([
        index_1.Post('/path/withFormData', true),
        __param(1, index_1.FormData('name'))
    ], TestImpl.prototype, "postWithEmptyFormDataAndQuery", null);
    __decorate([
        index_1.Post('/path/withUrlEncodedBody', true),
        __param(1, decorators_1.FormEncoding)
    ], TestImpl.prototype, "postWithUrlEncodedBody", null);
    __decorate([
        index_1.Put('/path')
    ], TestImpl.prototype, "put", null);
    __decorate([
        index_1.Put('/path', true)
    ], TestImpl.prototype, "putWithQuery", null);
    __decorate([
        index_1.Delete('/path/:id')
    ], TestImpl.prototype, "delete", null);
    __decorate([
        index_1.Delete('/path/:id', true)
    ], TestImpl.prototype, "deleteBody", null);
    __decorate([
        index_1.Delete('/path/:id', false, true)
    ], TestImpl.prototype, "deleteWithQuery", null);
    __decorate([
        index_1.Patch('/path/:id')
    ], TestImpl.prototype, "patchBody", null);
    __decorate([
        index_1.Get('/some/url'),
        decorators_1.ResponseType(UserClass)
    ], TestImpl.prototype, "withResponseType", null);
    __decorate([
        index_1.Get('/some/other/url'),
        decorators_1.ResponseType(UserClass, UserClass.transform)
    ], TestImpl.prototype, "withResponseTypeAndTransform", null);
    return TestImpl;
}());
var mockResponse = {
    key: 'value'
};
function setup() {
    return index_1.Pretend.builder().target(TestImpl, 'http://host:port/');
}
test('Pretend should call a get method without any parameter or query', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').get('/path').reply(200, mockResponse);
                return [4 /*yield*/, test.getSimple()];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a get method', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').get('/path/id').reply(200, mockResponse);
                return [4 /*yield*/, test.get('id')];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a get method with query parameters', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').get('/path/id?a=b&c=d').reply(200, mockResponse);
                return [4 /*yield*/, test.getWithQuery('id', { a: 'b', c: 'd' })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a get method and add a custom header', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/', {
                    reqheaders: {
                        accept: 'accept'
                    }
                })
                    .get('/with/header')
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.getWithHeader()];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should throw on wrong custom header format', function () { return __awaiter(void 0, void 0, void 0, function () {
    var Api, test, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                Api = /** @class */ (function () {
                    /* tslint:disable */
                    function Api() {
                    }
                    Api.prototype.get = function () {
                        return undefined;
                    };
                    __decorate([
                        index_1.Headers('syntactically-wrong'),
                        index_1.Get('/path')
                    ], Api.prototype, "get", null);
                    return Api;
                }());
                test = index_1.Pretend.builder().target(Api, 'http://host:port/');
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, test.get()];
            case 2:
                _a.sent();
                fail('should throw');
                return [3 /*break*/, 4];
            case 3:
                e_1 = _a.sent();
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a post method', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/')
                    .post('/path', { mockResponse: mockResponse })
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.post({ mockResponse: mockResponse })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a post method with query and body', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/')
                    .post('/path?query=param', { mockResponse: mockResponse })
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.postWithQueryAndBody({ query: 'param' }, { mockResponse: mockResponse })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a post method with FormData', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/', {
                    reqheaders: {
                        'Content-Type': /^multipart\/form-data/
                    }
                })
                    .post('/path/withFormData', /Content-Disposition: form-data; name="name"/)
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.postWithFormData(Buffer.alloc(10).toString('UTF-8'))];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a post method with FormData and query', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/', {
                    reqheaders: {
                        'Content-Type': /^multipart\/form-data/
                    }
                })
                    .post('/path/withFormData?query=params', /Content-Disposition: form-data; name="name"/)
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.postWithFormDataAndQuery({ query: 'params' }, Buffer.alloc(10).toString('UTF-8'))];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a post method with empty FormData and query', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/', {
                    reqheaders: {
                        'Content-Type': /^multipart\/form-data/
                    }
                })
                    .post('/path/withFormData?query=params', undefined)
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.postWithEmptyFormDataAndQuery({ query: 'params' }, undefined)];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a post method and form-encode the body', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/')
                    .post('/path/withUrlEncodedBody?query=params', 'p1=d1&p2=a%20b')
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.postWithUrlEncodedBody({ query: 'params' }, { p1: 'd1', p2: 'a b' })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a put method', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = index_1.Pretend.builder().target(TestImpl, 'http://host:port');
                nock_1.default('http://host:port/').put('/path').reply(200, mockResponse);
                return [4 /*yield*/, test.put()];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a put method with query parameters', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').put('/path?query=param').reply(200, mockResponse);
                return [4 /*yield*/, test.putWithQuery({ query: 'param' })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a delete method', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').delete('/path/id').reply(200, mockResponse);
                return [4 /*yield*/, test.delete('id')];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should throw on error', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, e_2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').delete('/path/id').replyWithError('server-fail');
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, test.delete('id')];
            case 2:
                _a.sent();
                fail('should throw');
                return [3 /*break*/, 4];
            case 3:
                e_2 = _a.sent();
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a delete method and send a body', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/')
                    .delete('/path/id', { data: 'data' })
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.deleteBody('id', { data: 'data' })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a delete method and append query parameters', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/')
                    .delete('/path/id?param=value')
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.deleteWithQuery('id', { param: 'value' })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should call a patch method and send a body', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/')
                    .patch('/path/id', { data: 'data' })
                    .reply(200, mockResponse);
                return [4 /*yield*/, test.patchBody('id', { data: 'data' })];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should return content based on decoder configuration', function () { return __awaiter(void 0, void 0, void 0, function () {
    var Api, decoderCalled, api, text;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                Api = /** @class */ (function () {
                    /* tslint:disable */
                    function Api() {
                    }
                    Api.prototype.get = function () {
                        return undefined;
                    };
                    __decorate([
                        index_1.Get('/path')
                    ], Api.prototype, "get", null);
                    return Api;
                }());
                /* tslint:enable */
                nock_1.default('http://host:port/').get('/path').reply(200, 'some-string');
                decoderCalled = false;
                api = index_1.Pretend.builder()
                    .decode(function (res) {
                    decoderCalled = true;
                    return res.text();
                })
                    .target(Api, 'http://host:port/');
                return [4 /*yield*/, api.get()];
            case 1:
                text = _a.sent();
                expect(decoderCalled).toBeTruthy();
                expect(text).toBe('some-string');
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should use basic auth if configured', function () { return __awaiter(void 0, void 0, void 0, function () {
    var Api, api, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                Api = /** @class */ (function () {
                    /* tslint:disable */
                    function Api() {
                    }
                    Api.prototype.get = function () {
                        return undefined;
                    };
                    __decorate([
                        index_1.Get('/')
                    ], Api.prototype, "get", null);
                    return Api;
                }());
                /* tslint:enable */
                nock_1.default('http://host:port/', {
                    reqheaders: {
                        Authorization: 'Basic QWxhZGRpbjpPcGVuU2VzYW1l'
                    }
                })
                    .get('/')
                    .reply(200, '{}');
                api = index_1.Pretend.builder()
                    .basicAuthentication('Aladdin', 'OpenSesame')
                    .target(Api, 'http://host:port');
                return [4 /*yield*/, api.get()];
            case 1:
                response = _a.sent();
                expect(response).toEqual({});
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should return from the interceptor', function () { return __awaiter(void 0, void 0, void 0, function () {
    var firstReponse, test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                nock_1.default('http://host:port/')
                    .get('/path/id')
                    .reply(200, mockResponse)
                    .get('/path/id')
                    .reply(500, {});
                firstReponse = undefined;
                test = index_1.Pretend.builder()
                    .interceptor(function (chain, request) {
                    if (!firstReponse) {
                        firstReponse = chain(request);
                    }
                    return firstReponse;
                })
                    .target(TestImpl, 'http://host:port/');
                // first call gets through
                return [4 /*yield*/, test.get('id')];
            case 1:
                // first call gets through
                _a.sent();
                return [4 /*yield*/, test.get('id')];
            case 2:
                response = _a.sent();
                // second should be return from the interceptor (nock would fail)
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should reset per-request data after each request', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').get('/with/header').reply(200, mockResponse);
                return [4 /*yield*/, test.getWithHeader()];
            case 1:
                _a.sent();
                expect(test.__Pretend__.perRequest).toBeUndefined();
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should reset per-request data after error requests', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, e_3;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                test = setup();
                nock_1.default('http://host:port/').get('/with/header').replyWithError('failed');
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4 /*yield*/, test.getWithHeader()];
            case 2:
                _a.sent();
                return [3 /*break*/, 4];
            case 3:
                e_3 = _a.sent();
                expect(test.__Pretend__.perRequest).toBeUndefined();
                return [3 /*break*/, 4];
            case 4: return [2 /*return*/];
        }
    });
}); });
test('Pretend should return from the interceptor with multiple chain calls', function () { return __awaiter(void 0, void 0, void 0, function () {
    var test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                nock_1.default('http://host:port/')
                    .get('/path/id')
                    .reply(200, mockResponse)
                    .get('/path/id')
                    .reply(500, {});
                test = index_1.Pretend.builder()
                    .interceptor(function (chain, request) {
                    return chain(request).then(function () { return chain(request); });
                })
                    .target(TestImpl, 'http://host:port/');
                return [4 /*yield*/, test.get('id')];
            case 1:
                response = _a.sent();
                expect(response).toEqual(mockResponse);
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should map responses to a given result type', function () { return __awaiter(void 0, void 0, void 0, function () {
    var scope, test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                scope = nock_1.default('http://host:port/')
                    .get('/some/url')
                    .reply(200, { user: 'name' });
                test = index_1.Pretend.builder().target(TestImpl, 'http://host:port/');
                return [4 /*yield*/, test.withResponseType()];
            case 1:
                response = _a.sent();
                expect(response).toBeInstanceOf(UserClass);
                expect(response.user).toBe('name');
                scope.done();
                return [2 /*return*/];
        }
    });
}); });
test('Pretend should map responses to a given result type using a transform', function () { return __awaiter(void 0, void 0, void 0, function () {
    var scope, test, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                scope = nock_1.default('http://host:port/')
                    .get('/some/other/url')
                    .reply(200, { firstName: 'firstname', lastName: 'lastname' });
                test = index_1.Pretend.builder().target(TestImpl, 'http://host:port/');
                return [4 /*yield*/, test.withResponseTypeAndTransform()];
            case 1:
                response = _a.sent();
                expect(response).toBeInstanceOf(UserClass);
                expect(response.user).toBe('firstname lastname');
                scope.done();
                return [2 /*return*/];
        }
    });
}); });
//# sourceMappingURL=index.test.js.map