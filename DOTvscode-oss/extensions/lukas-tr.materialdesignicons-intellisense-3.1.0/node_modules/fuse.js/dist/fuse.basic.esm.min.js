/**
 * Fuse.js v6.2.0 - Lightweight fuzzy-search (http://fusejs.io)
 *
 * Copyright (c) 2020 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */
function e(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}function t(e){return"string"==typeof e}function s(e){return"number"==typeof e}function n(e){return null!=e}function i(e){return!e.trim().length}const r=Object.prototype.hasOwnProperty;class o{constructor(e){this._keys={},this._keyNames=[];let s=0;e.forEach(e=>{let n,i=1;if(t(e))n=e;else{if(!r.call(e,"name"))throw new Error(`Missing ${"name"} property in key`);if(n=e.name,r.call(e,"weight")&&(i=e.weight,i<=0))throw new Error((e=>`Property 'weight' in key '${e}' must be a positive integer`)(n))}this._keyNames.push(n),this._keys[n]={weight:i},s+=i}),this._keyNames.forEach(e=>{this._keys[e].weight/=s})}get(e,t){return this._keys[e]&&this._keys[e][t]}keys(){return this._keyNames}toJSON(){return JSON.stringify(this._keys)}}var c={isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(e,t)=>e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1,includeMatches:!1,findAllMatches:!1,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:!1,getFn:function(i,r){let o=[],c=!1;const h=(i,r)=>{if(r){const a=r.indexOf(".");let l=r,d=null;-1!==a&&(l=r.slice(0,a),d=r.slice(a+1));const u=i[l];if(!n(u))return;if(d||!t(u)&&!s(u))if(e(u)){c=!0;for(let e=0,t=u.length;e<t;e+=1)h(u[e],d)}else d&&h(u,d);else o.push(function(e){return null==e?"":function(e){if("string"==typeof e)return e;let t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)}(u))}else o.push(i)};return h(i,r),c?o:o[0]},ignoreLocation:!1,ignoreFieldNorm:!1}};const h=/[^ ]+/g;class a{constructor({getFn:e=c.getFn}={}){this.norm=function(e=3){const t=new Map;return{get(s){const n=s.match(h).length;if(t.has(n))return t.get(n);const i=parseFloat((1/Math.sqrt(n)).toFixed(e));return t.set(n,i),i},clear(){t.clear()}}}(3),this.getFn=e,this.isCreated=!1,this.setIndexRecords()}setSources(e=[]){this.docs=e}setIndexRecords(e=[]){this.records=e}setKeys(e=[]){this.keys=e}create(){!this.isCreated&&this.docs.length&&(this.isCreated=!0,t(this.docs[0])?this.docs.forEach((e,t)=>{this._addString(e,t)}):this.docs.forEach((e,t)=>{this._addObject(e,t)}),this.norm.clear())}add(e){const s=this.size();t(e)?this._addString(e,s):this._addObject(e,s)}removeAt(e){this.records.splice(e,1);for(let t=e,s=this.size();t<s;t+=1)this.records[t].i-=1}size(){return this.records.length}_addString(e,t){if(!n(e)||i(e))return;let s={v:e,i:t,n:this.norm.get(e)};this.records.push(s)}_addObject(s,r){let o={i:r,$:{}};this.keys.forEach((r,c)=>{let h=this.getFn(s,r);if(n(h))if(e(h)){let s=[];const r=[{nestedArrIndex:-1,value:h}];for(;r.length;){const{nestedArrIndex:o,value:c}=r.pop();if(n(c))if(t(c)&&!i(c)){let e={v:c,i:o,n:this.norm.get(c)};s.push(e)}else e(c)&&c.forEach((e,t)=>{r.push({nestedArrIndex:t,value:e})})}o.$[c]=s}else if(!i(h)){let e={v:h,n:this.norm.get(h)};o.$[c]=e}}),this.records.push(o)}toJSON(){return{keys:this.keys,records:this.records}}}function l(e,t,{getFn:s=c.getFn}={}){const n=new a({getFn:s}),i=new o(e);return n.setKeys(i.keys()),n.setSources(t),n.create(),n}function d(e,t){const s=e.matches;t.matches=[],n(s)&&s.forEach(e=>{if(!n(e.indices)||!e.indices.length)return;const{indices:s,value:i}=e;let r={indices:s,value:i};e.key&&(r.key=e.key),e.idx>-1&&(r.refIndex=e.idx),t.matches.push(r)})}function u(e,t){t.score=e.score}function f(e,{errors:t=0,currentLocation:s=0,expectedLocation:n=0,distance:i=c.distance,ignoreLocation:r=c.ignoreLocation}={}){const o=t/e.length;if(r)return o;const h=Math.abs(n-s);return i?o+h/i:h?1:o}function g(e,t,s,{location:n=c.location,distance:i=c.distance,threshold:r=c.threshold,findAllMatches:o=c.findAllMatches,minMatchCharLength:h=c.minMatchCharLength,includeMatches:a=c.includeMatches,ignoreLocation:l=c.ignoreLocation}={}){if(t.length>32)throw new Error(`Pattern length exceeds max of ${32}.`);const d=t.length,u=e.length,g=Math.max(0,Math.min(n,u));let p=r,m=g;const y=h>1||a,M=y?Array(u):[];let x;for(;(x=e.indexOf(t,m))>-1;){let e=f(t,{currentLocation:x,expectedLocation:g,distance:i,ignoreLocation:l});if(p=Math.min(e,p),m=x+d,y){let e=0;for(;e<d;)M[x+e]=1,e+=1}}m=-1;let L=[],_=1,k=d+u;const v=1<<d-1;for(let n=0;n<d;n+=1){let r=0,c=k;for(;r<c;){f(t,{errors:n,currentLocation:g+c,expectedLocation:g,distance:i,ignoreLocation:l})<=p?r=c:k=c,c=Math.floor((k-r)/2+r)}k=c;let h=Math.max(1,g-c+1),a=o?u:Math.min(g+c,u)+d,x=Array(a+2);x[a+1]=(1<<n)-1;for(let r=a;r>=h;r-=1){let o=r-1,c=s[e.charAt(o)];if(y&&(M[o]=+!!c),x[r]=(x[r+1]<<1|1)&c,n&&(x[r]|=(L[r+1]|L[r])<<1|1|L[r+1]),x[r]&v&&(_=f(t,{errors:n,currentLocation:o,expectedLocation:g,distance:i,ignoreLocation:l}),_<=p)){if(p=_,m=o,m<=g)break;h=Math.max(1,2*g-m)}}if(f(t,{errors:n+1,currentLocation:g,expectedLocation:g,distance:i,ignoreLocation:l})>p)break;L=x}const w={isMatch:m>=0,score:Math.max(.001,_)};if(y){const e=function(e=[],t=c.minMatchCharLength){let s=[],n=-1,i=-1,r=0;for(let o=e.length;r<o;r+=1){let o=e[r];o&&-1===n?n=r:o||-1===n||(i=r-1,i-n+1>=t&&s.push([n,i]),n=-1)}return e[r-1]&&r-n>=t&&s.push([n,r-1]),s}(M,h);e.length?a&&(w.indices=e):w.isMatch=!1}return w}function p(e){let t={};for(let s=0,n=e.length;s<n;s+=1){const i=e.charAt(s);t[i]=(t[i]||0)|1<<n-s-1}return t}class m{constructor(e,{location:t=c.location,threshold:s=c.threshold,distance:n=c.distance,includeMatches:i=c.includeMatches,findAllMatches:r=c.findAllMatches,minMatchCharLength:o=c.minMatchCharLength,isCaseSensitive:h=c.isCaseSensitive,ignoreLocation:a=c.ignoreLocation}={}){if(this.options={location:t,threshold:s,distance:n,includeMatches:i,findAllMatches:r,minMatchCharLength:o,isCaseSensitive:h,ignoreLocation:a},this.pattern=h?e:e.toLowerCase(),this.chunks=[],!this.pattern.length)return;const l=(e,t)=>{this.chunks.push({pattern:e,alphabet:p(e),startIndex:t})},d=this.pattern.length;if(d>32){let e=0;const t=d%32,s=d-t;for(;e<s;)l(this.pattern.substr(e,32),e),e+=32;if(t){const e=d-32;l(this.pattern.substr(e),e)}}else l(this.pattern,0)}searchIn(e){const{isCaseSensitive:t,includeMatches:s}=this.options;if(t||(e=e.toLowerCase()),this.pattern===e){let t={isMatch:!0,score:0};return s&&(t.indices=[[0,e.length-1]]),t}const{location:n,distance:i,threshold:r,findAllMatches:o,minMatchCharLength:c,ignoreLocation:h}=this.options;let a=[],l=0,d=!1;this.chunks.forEach(({pattern:t,alphabet:u,startIndex:f})=>{const{isMatch:p,score:m,indices:y}=g(e,t,u,{location:n+f,distance:i,threshold:r,findAllMatches:o,minMatchCharLength:c,includeMatches:s,ignoreLocation:h});p&&(d=!0),l+=m,p&&y&&(a=[...a,...y])});let u={isMatch:d,score:d?l/this.chunks.length:1};return d&&s&&(u.indices=a),u}}const y=[];function M(e,t){for(let s=0,n=y.length;s<n;s+=1){let n=y[s];if(n.condition(e,t))return new n(e,t)}return new m(e,t)}class x{constructor(e,t={},s){if(this.options={...c,...t},this.options.useExtendedSearch)throw new Error("Extended search is not available");this._keyStore=new o(this.options.keys),this.setCollection(e,s)}setCollection(e,t){if(this._docs=e,t&&!(t instanceof a))throw new Error("Incorrect 'index' type");this._myIndex=t||l(this._keyStore.keys(),this._docs,{getFn:this.options.getFn})}add(e){n(e)&&(this._docs.push(e),this._myIndex.add(e))}remove(e=(()=>!1)){const t=[];for(let s=0,n=this._docs.length;s<n;s+=1){const n=this._docs[s];e(n,s)&&(this.removeAt(s),s-=1,t.push(n))}return t}removeAt(e){this._docs.splice(e,1),this._myIndex.removeAt(e)}getIndex(){return this._myIndex}search(e,{limit:n=-1}={}){const{includeMatches:i,includeScore:r,shouldSort:o,sortFn:h,ignoreFieldNorm:a}=this.options;let l=t(e)?t(this._docs[0])?this._searchStringList(e):this._searchObjectList(e):this._searchLogical(e);return function(e,t,{ignoreFieldNorm:s=c.ignoreFieldNorm}){e.forEach(e=>{let n=1;e.matches.forEach(({key:e,norm:i,score:r})=>{const o=t.get(e,"weight");n*=Math.pow(0===r&&o?Number.EPSILON:r,(o||1)*(s?1:i))}),e.score=n})}(l,this._keyStore,{ignoreFieldNorm:a}),o&&l.sort(h),s(n)&&n>-1&&(l=l.slice(0,n)),function(e,t,{includeMatches:s=c.includeMatches,includeScore:n=c.includeScore}={}){const i=[];s&&i.push(d);n&&i.push(u);return e.map(e=>{const{idx:s}=e,n={item:t[s],refIndex:s};return i.length&&i.forEach(t=>{t(e,n)}),n})}(l,this._docs,{includeMatches:i,includeScore:r})}_searchStringList(e){const t=M(e,this.options),{records:s}=this._myIndex,i=[];return s.forEach(({v:e,i:s,n:r})=>{if(!n(e))return;const{isMatch:o,score:c,indices:h}=t.searchIn(e);o&&i.push({item:e,idx:s,matches:[{score:c,value:e,norm:r,indices:h}]})}),i}_searchLogical(e){throw new Error("Logical search is not available")}_searchObjectList(e){const t=M(e,this.options),{keys:s,records:i}=this._myIndex,r=[];return i.forEach(({$:e,i:i})=>{if(!n(e))return;let o=[];s.forEach((s,n)=>{o.push(...this._findMatches({key:s,value:e[n],searcher:t}))}),o.length&&r.push({idx:i,item:e,matches:o})}),r}_findMatches({key:t,value:s,searcher:i}){if(!n(s))return[];let r=[];if(e(s))s.forEach(({v:e,i:s,n:o})=>{if(!n(e))return;const{isMatch:c,score:h,indices:a}=i.searchIn(e);c&&r.push({score:h,key:t,value:e,idx:s,norm:o,indices:a})});else{const{v:e,n:n}=s,{isMatch:o,score:c,indices:h}=i.searchIn(e);o&&r.push({score:c,key:t,value:e,norm:n,indices:h})}return r}}x.version="6.2.0",x.createIndex=l,x.parseIndex=function(e,{getFn:t=c.getFn}={}){const{keys:s,records:n}=e,i=new a({getFn:t});return i.setKeys(s),i.setIndexRecords(n),i},x.config=c;export default x;